# 2. 史诗和故事

### 史诗 1：混合匹配与 UI 增强

> **依赖链说明**：本史诗按“数据模型 → 核心匹配 → CLI/UI → 数据服务”的顺序推进。任何故事未通过验收将阻断后续故事进入开发；解除阻断需由对应负责人在架构文档第 6.1 节更新状态并获得 PO 确认。

**史诗描述：** 彻底重构匹配逻辑，以支持精确路径、元数据和模糊匹配，同时更新 UI 以支持拖放和新的配置模型。

**故事 1.1：更新数据模型和配置加载（混合模式）**
* **作为** 架构师,
* **我想要** 修改 `GameConfig` 模型 以支持可选的 `ExecutablePath` 和必需的 `DataKey`,
* **以便** 配置系统能同时处理新（路径）旧（名称）格式，并确保数据关联 的完整性。
* **验收标准：**
    1.  `GameConfig.cs` 必须包含：`DataKey` (string, 必需), `ExecutablePath` (string, 可选), `ExecutableName` (string, 可选), `DisplayName` (string, 可选)。
    2.  `YamlConfigProvider.cs` 加载时*必须*要求 `DataKey` 存在，否则抛出错误。
    3.  `YamlConfigProvider.cs` 必须能成功加载同时包含 `ExecutablePath` 和 `ExecutableName` 的条目。
    4.  `YamlConfigProvider.cs` 加载*只*包含 `ExecutableName`（没有 `ExecutablePath`）的条目时，必须成功加载，并记录一个“警告”日志。

**故事 1.2：更新核心匹配逻辑（混合策略）**
* **作为** 系统,
* **我想要** 在 `GameAutomationService` 中实现一个 2 级匹配策略,
* **以便** 优先使用精确路径匹配，同时为旧配置保留增强的（元数据/模糊）名称匹配。
* **验收标准：**
    1.  服务启动时，`GameConfig` 列表必须被分成 `PathBasedConfigs` 和 `NameBasedConfigs` 两个列表。
    2.  **第 1 级（路径匹配）：** 当进程事件到达时，必须*首先*尝试将其 `exePath` 与 `PathBasedConfigs` 列表进行精确（不区分大小写）匹配。
    3.  **第 2 级（回退匹配）：** 仅当第 1 级匹配失败时，才尝试第 2 级。
    4.  第 2 级必须尝试从 `exePath` 获取 `FileVersionInfo.ProductName`。
    5.  第 2 级必须使用 `FuzzySharp` 将 `ProductName`（或 `exeName`）与 `NameBasedConfigs` 列表中的 `config.ExecutableName` 进行比较。
    6.  如果模糊匹配（例如 `Fuzz.Ratio` > 80）成功，则匹配该配置。
    7.  所有旧的（非元数据/模糊）前缀或词干匹配逻辑必须被移除。

**故事 1.3：更新 UI 以支持拖放和新配置**
* **作为** 用户,
* **我想要** 能够通过拖放 EXE 或 LNK 文件来添加新游戏,
* **以便** 快速配置新游戏并自动提取其元数据。
* **验收标准：**
    1.  `ConsoleHost` 必须能接受文件拖放。
    2.  如果拖放的是 LNK（快捷方式），系统必须能解析出目标的 EXE 路径。
    3.  系统必须使用 `FileVersionInfo.GetVersionInfo(path)` 尝试提取 `ProductName`。
    4.  必须提示用户确认自动提取的 `ProductName` 作为 `DataKey`，并将 EXE 路径作为 `ExecutablePath`。
    5.  `InteractiveShell.cs` 中的“添加游戏”命令必须更新，以提示输入 `ExecutablePath` 和 `DataKey`。
    6.  （可选）必须提供一个“编辑游戏”命令，允许为现有配置添加 `ExecutablePath`。

**故事 1.4：确保数据服务的数据关联**
* **作为** 用户,
* **我想要** 无论游戏是通过路径还是名称匹配的，我的游戏时长都能正确记录和报告,
* **以便** 保持我的历史数据连续性。
* **验收标准：**
    1.  `CsvBackedPlayTimeService.cs` 在记录新会话时，必须使用匹配到的 `GameConfig` 上的 `DataKey` 字段作为 `GameName` 写入 `playtime.csv`。
    2.  `stats` 命令在读取 `playtime.csv` 时，必须按 CSV 中的 `game` 列值直接分组（不实现复杂匹配逻辑）。
    3.  `stats` 命令在显示时，如果 CSV 的 `game` 值能匹配到配置的 `DataKey`，则优先使用 `GameConfig.DisplayName`；否则直接显示 CSV 中的原始值。
    4.  `stats` 命令能够读取包含旧格式（EXE 名称）的 CSV 文件，并显示这些记录（使用原始值，不自动合并）。

**故事 1.5：历史数据迁移工具**
* **作为** 用户,
* **我想要** 一个工具能够将我的历史游戏时长数据从旧格式（EXE 名称）迁移到新格式（DataKey）,
* **以便** 统一数据格式，使统计报告更准确和一致。
* **验收标准：**
    1.  必须提供 `migrate-playtime` 或类似的 CLI 命令。
    2.  命令必须能够扫描 `playtime.csv` 中的所有记录，识别使用旧格式（EXE 名称）的记录。
    3.  对于每条旧格式记录，必须尝试通过以下策略匹配到对应的 `GameConfig`：
        - 精确匹配 `ExecutableName`（不区分大小写）
        - 模糊匹配（使用 `FuzzySharp`，阈值 > 80）
    4.  匹配成功后，必须将记录的 `game` 列从 EXE 名称更新为对应的 `DataKey`。
    5.  命令必须提供 **预览模式**（`--dry-run` 或 `--preview`），显示将要进行的更改但不实际修改文件。
    6.  命令必须提供详细的迁移报告，包括：
        - 扫描的总记录数
        - 成功迁移的记录数
        - 无法匹配的记录列表（需要用户手动处理）
        - 已经是新格式的记录数（跳过）
    7.  命令必须在修改 CSV 前**自动备份**原文件（如 `playtime.csv.backup.YYYYMMDDHHMMSS`）。
    8.  对于无法自动匹配的记录，必须提供清晰的提示，建议用户如何手动处理（如手动编辑配置或 CSV）。
* **技术约束：**
    - 必须保持 CSV 文件格式不变（列数、顺序、编码）
    - 必须保留原始的时间戳和时长数据（只修改 `game` 列）
    - 必须处理特殊字符转义（逗号、引号等）
    - 迁移操作必须是原子的（失败时可回滚）
* **用户体验要求：**
    - 提供进度指示（处理大文件时）
    - 使用彩色输出区分成功/警告/错误信息
    - 提供交互式确认（除非使用 `--force` 参数）
    - 在预览模式下，清晰展示前后对比

**故事 1.6：将 ETW 设为默认进程监听方式**
* **作为** 系统管理员,
* **我想要** ETW 成为默认的进程监听方式,
* **以便** 获得更好的性能和更低的系统资源占用。
* **验收标准：**
    1.  `AppConfig.ProcessMonitorType` 的默认值必须为 `ProcessMonitorType.ETW`。
    2.  当配置文件未指定 `processMonitorType` 时，系统必须使用 ETW。
    3.  用户仍可通过配置文件显式指定 `processMonitorType: WMI` 来使用 WMI。
    4.  命令行参数 `--monitor-type` 的优先级保持不变（最高优先级）。
    5.  现有的 WMI 监听功能必须保持完全可用。
    6.  `ProcessMonitorFactory.CreateWithFallback()` 的降级逻辑必须保持不变。
    7.  所有现有测试必须继续通过（可能需要调整默认值相关的测试）。
    8.  `README.md` 必须更新，说明 ETW 是默认值，WMI 是可选项。
    9.  示例配置文件必须更新以反映新的默认值和最佳实践。
    10. 必须添加关于 ETW 管理员权限要求的清晰说明。
    11. 必须更新迁移指南，说明如何继续使用 WMI（如果需要）。
    12. 所有相关单元测试必须更新并通过。
    13. 集成测试必须验证默认行为。
    14. 必须添加测试验证显式配置 WMI 仍然有效。