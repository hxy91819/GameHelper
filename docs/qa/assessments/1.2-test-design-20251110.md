# Test Design: Story 1.2 - 混合匹配策略

Date: 2025-11-10
Designer: Quinn (Test Architect)

## Test Strategy Overview

- Total test scenarios: 18
- Unit tests: 18 (100%)
- Integration tests: 0 (建议未来添加)
- E2E tests: 0 (不适用)
- Priority distribution: P0: 12, P1: 6

## Test Scenarios by Acceptance Criteria

### AC1: 配置分组逻辑

服务启动时，`GameConfig` 列表必须被分成 `PathBasedConfigs` 和 `NameBasedConfigs` 两个列表。

#### Scenarios

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 1.2-UNIT-001 | Unit | P0 | 配置有 ExecutablePath 时分到 PathBased | 核心分组逻辑 |
| 1.2-UNIT-002 | Unit | P0 | 配置仅有 ExecutableName 时分到 NameBased | 核心分组逻辑 |
| 1.2-UNIT-003 | Unit | P0 | 配置同时有 Path 和 Name 时分到 PathBased | 路径优先策略 |
| 1.2-UNIT-004 | Unit | P1 | 禁用的配置不被分组 | 边界条件 |

### AC2: L1 路径匹配

当进程事件到达时，必须*首先*尝试将其 `exePath` 与 `PathBasedConfigs` 列表进行精确（不区分大小写）匹配。

#### Scenarios

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 1.2-UNIT-005 | Unit | P0 | 精确路径匹配成功 | 核心 L1 功能 |
| 1.2-UNIT-006 | Unit | P0 | 不区分大小写路径匹配 | 核心 L1 功能 |
| 1.2-UNIT-007 | Unit | P0 | 路径不匹配返回 null | 核心 L1 功能 |
| 1.2-UNIT-008 | Unit | P1 | 路径规范化处理（斜杠、大小写） | 边界条件 |

### AC3: L2 回退匹配

仅当第 1 级匹配失败时，才尝试第 2 级。

#### Scenarios

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 1.2-UNIT-009 | Unit | P0 | L1 成功时不执行 L2 | 核心流程控制 |
| 1.2-UNIT-010 | Unit | P0 | L1 失败时执行 L2 | 核心流程控制 |

### AC4: ProductName 获取

第 2 级必须尝试从 `exePath` 获取 `FileVersionInfo.ProductName`。

#### Scenarios

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 1.2-UNIT-011 | Unit | P0 | ProductName 可用时使用 ProductName | 核心 L2 功能 |
| 1.2-UNIT-012 | Unit | P0 | ProductName 不可用时回退到 exeName | 核心 L2 功能 |
| 1.2-UNIT-013 | Unit | P1 | FileVersionInfo 异常时回退到 exeName | 错误处理 |

### AC5 & AC6: 模糊匹配

第 2 级必须使用 `FuzzySharp` 将 `ProductName`（或 `exeName`）与 `NameBasedConfigs` 列表中的 `config.ExecutableName` 进行比较。如果模糊匹配（例如 `Fuzz.Ratio` > 80）成功，则匹配该配置。

#### Scenarios

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 1.2-UNIT-014 | Unit | P0 | 模糊匹配分数 > 80 时匹配成功 | 核心模糊匹配 |
| 1.2-UNIT-015 | Unit | P0 | 模糊匹配分数 = 80 时匹配成功 | 阈值边界 |
| 1.2-UNIT-016 | Unit | P0 | 模糊匹配分数 < 80 时匹配失败 | 阈值边界 |
| 1.2-UNIT-017 | Unit | P1 | 多个候选时选择最高分 | 最佳匹配逻辑 |
| 1.2-UNIT-018 | Unit | P1 | 无 NameBased 配置时返回 null | 边界条件 |

### AC7: 移除旧逻辑

所有旧的（非元数据/模糊）前缀或词干匹配逻辑必须被移除。

#### Verification

- ✅ 代码审查确认：`Stem()`, `BuildEnabledStemIndex()`, `FindEnabledStemCandidates()` 等方法已完全移除
- ✅ 代码审查确认：`_enabledStemIndex`, `_activeByStem` 字段已完全移除
- ⚠️ 需要回归测试确认旧逻辑不再工作

## Detailed Test Specifications

### 配置分组测试

```csharp
[Fact]
public void Start_ConfigWithExecutablePath_AddedToPathBasedConfigs()
{
    // Arrange
    var config = new GameConfig 
    { 
        DataKey = "game1",
        ExecutablePath = @"C:\Games\game.exe",
        ExecutableName = "game.exe",
        IsEnabled = true 
    };
    var configProvider = new FakeConfig(new Dictionary<string, GameConfig> { ["game1"] = config });
    var service = CreateService(configProvider);

    // Act
    service.Start();
    var monitor = GetMonitor(service);
    monitor.RaiseStart(new ProcessEventInfo("game.exe", @"C:\Games\game.exe"));

    // Assert
    // 验证通过路径匹配成功（检查日志或行为）
}

[Fact]
public void Start_ConfigWithOnlyExecutableName_AddedToNameBasedConfigs()
{
    // Arrange
    var config = new GameConfig 
    { 
        DataKey = "game1",
        ExecutableName = "game.exe",
        IsEnabled = true 
    };
    var configProvider = new FakeConfig(new Dictionary<string, GameConfig> { ["game1"] = config });
    var service = CreateService(configProvider);

    // Act
    service.Start();
    var monitor = GetMonitor(service);
    monitor.RaiseStart(new ProcessEventInfo("game.exe", null));

    // Assert
    // 验证通过名称模糊匹配成功
}

[Fact]
public void Start_ConfigWithBothPathAndName_PrioritizesPath()
{
    // Arrange
    var config = new GameConfig 
    { 
        DataKey = "game1",
        ExecutablePath = @"C:\Games\game.exe",
        ExecutableName = "different.exe",
        IsEnabled = true 
    };
    var configProvider = new FakeConfig(new Dictionary<string, GameConfig> { ["game1"] = config });
    var service = CreateService(configProvider);

    // Act
    service.Start();
    var monitor = GetMonitor(service);
    monitor.RaiseStart(new ProcessEventInfo("game.exe", @"C:\Games\game.exe"));

    // Assert
    // 验证通过路径匹配（而非名称）
}

[Fact]
public void Start_DisabledConfig_NotAddedToAnyList()
{
    // Arrange
    var config = new GameConfig 
    { 
        DataKey = "game1",
        ExecutablePath = @"C:\Games\game.exe",
        IsEnabled = false 
    };
    var configProvider = new FakeConfig(new Dictionary<string, GameConfig> { ["game1"] = config });
    var service = CreateService(configProvider);

    // Act
    service.Start();
    var monitor = GetMonitor(service);
    monitor.RaiseStart(new ProcessEventInfo("game.exe", @"C:\Games\game.exe"));

    // Assert
    // 验证未启动跟踪（检查 PlayTimeService 未被调用）
}
```

### L1 路径匹配测试

```csharp
[Fact]
public void OnProcessStarted_ExactPathMatch_MatchesConfig()
{
    // Arrange
    var config = new GameConfig 
    { 
        DataKey = "game1",
        ExecutablePath = @"C:\Games\game.exe",
        IsEnabled = true 
    };
    var service = CreateServiceWithConfig(config);
    service.Start();

    // Act
    var monitor = GetMonitor(service);
    monitor.RaiseStart(new ProcessEventInfo("game.exe", @"C:\Games\game.exe"));

    // Assert
    // 验证 PlayTimeService.StartTracking("game1") 被调用
}

[Fact]
public void OnProcessStarted_CaseInsensitivePathMatch_MatchesConfig()
{
    // Arrange
    var config = new GameConfig 
    { 
        DataKey = "game1",
        ExecutablePath = @"C:\Games\game.exe",
        IsEnabled = true 
    };
    var service = CreateServiceWithConfig(config);
    service.Start();

    // Act
    var monitor = GetMonitor(service);
    monitor.RaiseStart(new ProcessEventInfo("GAME.EXE", @"c:\games\GAME.EXE"));

    // Assert
    // 验证匹配成功
}

[Fact]
public void OnProcessStarted_PathNotMatch_ReturnsNull()
{
    // Arrange
    var config = new GameConfig 
    { 
        DataKey = "game1",
        ExecutablePath = @"C:\Games\game.exe",
        IsEnabled = true 
    };
    var service = CreateServiceWithConfig(config);
    service.Start();

    // Act
    var monitor = GetMonitor(service);
    monitor.RaiseStart(new ProcessEventInfo("other.exe", @"C:\Other\other.exe"));

    // Assert
    // 验证未启动跟踪
}

[Fact]
public void OnProcessStarted_PathNormalization_HandlesTrailingSlashes()
{
    // Arrange
    var config = new GameConfig 
    { 
        DataKey = "game1",
        ExecutablePath = @"C:\Games\game.exe",
        IsEnabled = true 
    };
    var service = CreateServiceWithConfig(config);
    service.Start();

    // Act
    var monitor = GetMonitor(service);
    monitor.RaiseStart(new ProcessEventInfo("game.exe", @"C:\Games\game.exe\"));

    // Assert
    // 验证路径规范化后匹配成功
}
```

### L2 模糊匹配测试

```csharp
[Fact]
public void OnProcessStarted_L1Fails_TriesL2()
{
    // Arrange
    var config = new GameConfig 
    { 
        DataKey = "game1",
        ExecutableName = "game.exe",
        IsEnabled = true 
    };
    var service = CreateServiceWithConfig(config);
    service.Start();

    // Act
    var monitor = GetMonitor(service);
    monitor.RaiseStart(new ProcessEventInfo("game.exe", null));

    // Assert
    // 验证通过 L2 匹配成功
}

[Fact]
public void OnProcessStarted_L1Succeeds_SkipsL2()
{
    // Arrange
    var pathConfig = new GameConfig 
    { 
        DataKey = "path-game",
        ExecutablePath = @"C:\Games\game.exe",
        IsEnabled = true 
    };
    var nameConfig = new GameConfig 
    { 
        DataKey = "name-game",
        ExecutableName = "game.exe",
        IsEnabled = true 
    };
    var service = CreateServiceWithConfigs(pathConfig, nameConfig);
    service.Start();

    // Act
    var monitor = GetMonitor(service);
    monitor.RaiseStart(new ProcessEventInfo("game.exe", @"C:\Games\game.exe"));

    // Assert
    // 验证使用 "path-game" 而非 "name-game"
}

[Fact]
public void OnProcessStarted_FuzzyMatchAboveThreshold_MatchesConfig()
{
    // Arrange
    var config = new GameConfig 
    { 
        DataKey = "game1",
        ExecutableName = "The Witcher 3",
        IsEnabled = true 
    };
    var service = CreateServiceWithConfig(config);
    service.Start();

    // Act
    var monitor = GetMonitor(service);
    // 模拟 ProductName = "Witcher3" (score 应该 > 80)
    monitor.RaiseStart(new ProcessEventInfo("witcher3.exe", @"C:\Games\witcher3.exe"));

    // Assert
    // 验证模糊匹配成功
}

[Fact]
public void OnProcessStarted_FuzzyMatchAtThreshold_MatchesConfig()
{
    // Arrange & Act & Assert
    // 需要找到一个恰好得分 80 的字符串对
    // 例如: "game" vs "gam" 可能得分接近 80
}

[Fact]
public void OnProcessStarted_FuzzyMatchBelowThreshold_DoesNotMatch()
{
    // Arrange
    var config = new GameConfig 
    { 
        DataKey = "game1",
        ExecutableName = "completely different",
        IsEnabled = true 
    };
    var service = CreateServiceWithConfig(config);
    service.Start();

    // Act
    var monitor = GetMonitor(service);
    monitor.RaiseStart(new ProcessEventInfo("game.exe", null));

    // Assert
    // 验证未匹配
}

[Fact]
public void OnProcessStarted_MultipleCandidates_SelectsHighestScore()
{
    // Arrange
    var config1 = new GameConfig 
    { 
        DataKey = "game1",
        ExecutableName = "game",
        IsEnabled = true 
    };
    var config2 = new GameConfig 
    { 
        DataKey = "game2",
        ExecutableName = "game.exe",
        IsEnabled = true 
    };
    var service = CreateServiceWithConfigs(config1, config2);
    service.Start();

    // Act
    var monitor = GetMonitor(service);
    monitor.RaiseStart(new ProcessEventInfo("game.exe", null));

    // Assert
    // 验证选择 "game2" (更高分数)
}

[Fact]
public void OnProcessStarted_FileVersionInfoThrows_FallsBackToExeName()
{
    // Arrange
    var config = new GameConfig 
    { 
        DataKey = "game1",
        ExecutableName = "game.exe",
        IsEnabled = true 
    };
    var service = CreateServiceWithConfig(config);
    service.Start();

    // Act
    var monitor = GetMonitor(service);
    // 提供一个不存在的路径，导致 FileVersionInfo 抛出异常
    monitor.RaiseStart(new ProcessEventInfo("game.exe", @"C:\NonExistent\game.exe"));

    // Assert
    // 验证回退到 exeName 匹配成功
}
```

## Test Infrastructure Requirements

### 更新 FakeMonitor

```csharp
file sealed class FakeMonitor : IProcessMonitor
{
    public event Action<ProcessEventInfo>? ProcessStarted;
    public event Action<ProcessEventInfo>? ProcessStopped;
    
    public void Start() { }
    public void Stop() { }
    public void Dispose() { }
    
    public void RaiseStart(ProcessEventInfo info) => ProcessStarted?.Invoke(info);
    public void RaiseStop(ProcessEventInfo info) => ProcessStopped?.Invoke(info);
}
```

### Mock FileVersionInfo (可选)

由于 `FileVersionInfo.GetVersionInfo()` 是静态方法，难以 mock。建议：
1. 使用真实文件系统测试（创建临时 .exe 文件）
2. 或者重构代码引入 `IFileVersionInfoProvider` 接口
3. 或者仅测试异常处理路径（使用不存在的文件）

## Recommended Execution Order

1. P0 配置分组测试 (1.2-UNIT-001 to 004)
2. P0 L1 路径匹配测试 (1.2-UNIT-005 to 007)
3. P0 L2 流程控制测试 (1.2-UNIT-009 to 010)
4. P0 模糊匹配核心测试 (1.2-UNIT-014 to 016)
5. P0 ProductName 测试 (1.2-UNIT-011 to 012)
6. P1 边界条件测试 (其余)

## Coverage Goals

- **Line Coverage**: > 90% for GameAutomationService
- **Branch Coverage**: > 85% for matching logic
- **Critical Paths**: 100% coverage for L1/L2 decision flow

## Risk Coverage

这些测试覆盖以下风险：
- **TECH-001**: 配置分组错误导致匹配失败
- **TECH-002**: L1/L2 流程控制错误
- **TECH-003**: 模糊匹配阈值不当
- **TECH-004**: FileVersionInfo 异常未处理
- **PERF-001**: 性能问题（需要额外的性能测试）

## Future Test Recommendations

1. **性能基准测试**
   - 测试 1000 个配置的匹配性能
   - 测试 FileVersionInfo 调用的性能影响
   - 测试模糊匹配的性能特征

2. **集成测试**
   - 使用真实进程监控器测试
   - 使用真实配置文件测试
   - 端到端流程测试

3. **压力测试**
   - 快速连续的进程启动/停止
   - 大量并发进程
   - 异常配置（空字符串、特殊字符等）
