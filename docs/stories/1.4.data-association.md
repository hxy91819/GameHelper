# Story 1.4: 确保数据服务的数据关联

## Status

Draft

## Story

**As a** 用户,
**I want** 无论游戏是通过路径还是名称匹配的，我的游戏时长都能正确记录和报告,
**so that** 保持我的历史数据连续性。

## Acceptance Criteria

1. `CsvBackedPlayTimeService.cs` 在记录新会话时，必须使用匹配到的 `GameConfig` 上的 `DataKey` 字段作为 `GameName` 写入 `playtime.csv`。
2. `stats` 命令在读取 `playtime.csv` 时，必须按 CSV 中的 `game` 列值（DataKey）分组。
3. `stats` 命令在显示时，必须优先使用 `GameConfig.DisplayName`（如果存在），其次使用 `DataKey` 作为游戏名称。
4. `stats` 命令对于 CSV 中存在但配置中不存在的游戏（孤立记录），应直接显示 CSV 中的原始值。

## Context and Background

**Epic 依赖链说明**: 本故事依赖于 Story 1.1（数据模型更新）和 Story 1.2（混合匹配策略）的完成。Story 1.1 已经引入了 `DataKey` 字段，Story 1.2 已经实现了混合匹配逻辑。本故事确保数据持久化层正确使用这些新字段。

**前序故事关键洞察**（来自 Story 1.3）：
- Story 1.3 实现了通过拖放添加游戏的 UI 功能
- 用户现在可以通过拖放 EXE/LNK 文件快速添加游戏，系统会自动提取 `ProductName` 作为 `DataKey` 建议
- `GameMetadataExtractor` 已实现并经过测试
- `YamlConfigProvider` 已经能够正确加载和保存包含 `DataKey` 的配置

**系统当前状态**：
- `GameConfig` 模型已包含 `DataKey`（必需）、`ExecutablePath`（可选）、`ExecutableName`（可选）、`DisplayName`（可选）
- `GameAutomationService` 已实现 2 级混合匹配策略（L1 路径精确匹配，L2 元数据/模糊回退）
- `playtime.csv` 格式：`game,start_time,end_time,duration_minutes`
- 当前的 CSV 列名是 `game`，但代码中使用 `GameName` 作为变量名

## Dev Technical Guidance

### 数据模型关联

**来源**: [docs/architecture/5-data-models-and-storage.md]

关键数据模型：
- `GameConfig.DataKey` (string, 必需): 关联 `playtime.csv` 的唯一标识符
- `GameConfig.DisplayName` (string, 可选): 用于 UI 显示的友好名称
- `playtime.csv` 的 `game` 列现在必须由 `GameConfig.DataKey` 填充

### CsvBackedPlayTimeService 修改要点

**当前实现位置**: `GameHelper.Infrastructure/Providers/CsvBackedPlayTimeService.cs`

**需要修改的方法**：
1. `AppendSessionToCsv(string gameName, ...)` - 当前直接使用传入的 `gameName` 参数
2. 需要确认 `GameAutomationService` 在调用 `StartTracking` 和 `StopTracking` 时传递的是 `DataKey` 而不是其他值

**CSV 格式说明**：
- 文件头：`game,start_time,end_time,duration_minutes`
- CSV 转义：使用 `EscapeCsvField()` 方法处理包含逗号或引号的游戏名称
- 时间格式：`yyyy-MM-ddTHH:mm:ss`（ISO 8601）

### StatsCommand 修改要点

**当前实现位置**: `GameHelper.ConsoleHost/Commands/StatsCommand.cs`

**当前行为**：
- 从 CSV 读取数据到 `List<GameItem>`
- 使用 `YamlConfigProvider` 加载配置，通过 `GameConfig.Alias` 显示别名
- **注意**: 代码中使用的是 `gc.Alias`，但 `GameConfig` 模型中没有 `Alias` 字段

**需要修改的逻辑**：
1. 第 67 行：当前使用 `gc.Alias` - 需要改为使用 `gc.DisplayName`
2. 显示优先级：`DisplayName` > `DataKey` > CSV 原始值
3. **简化的匹配策略**：
   - 首先尝试通过 DataKey 精确匹配配置
   - 如果匹配成功，使用 `DisplayName` 或 `DataKey`
   - 如果匹配失败（旧数据），直接使用 CSV 中的原始值

**简化后的代码逻辑** (第 59-68 行)：
```csharp
var projected = games
    .Select(g => new
    {
        Game = g,
        // 简化逻辑：尝试匹配 DataKey，失败则使用原始值
        Name = cfg.TryGetValue(g.GameName, out var gc) && !string.IsNullOrWhiteSpace(gc.DisplayName)
            ? gc.DisplayName!
            : (cfg.TryGetValue(g.GameName, out gc) ? gc.DataKey : g.GameName),
        TotalMinutes = g.Sessions?.Sum(s => s.DurationMinutes) ?? 0,
        RecentMinutes = g.Sessions?.Where(s => s.EndTime >= cutoff).Sum(s => s.DurationMinutes) ?? 0,
        SessionCount = g.Sessions?.Count ?? 0
    })
```

### GameAutomationService 集成验证

**当前实现位置**: `GameHelper.Core/Services/GameAutomationService.cs`

**需要验证**：
- `StartTracking` 调用时传递的参数是 `GameConfig.DataKey`
- `StopTracking` 调用时传递的参数是 `GameConfig.DataKey`
- 确保匹配成功后，使用的是 `config.DataKey` 而不是 `exeName` 或 `productName`

### 测试策略

**来源**: [docs/architecture/9-testing-status.md#9.1]

**必需的测试覆盖**：
1. **单元测试** (CsvBackedPlayTimeService):
   - 测试 `StartTracking` 和 `StopTracking` 使用正确的 DataKey
   - 测试 CSV 写入的游戏名称字段是 DataKey
   - 测试特殊字符（逗号、引号）的 DataKey 正确转义

2. **单元测试** (StatsCommand):
   - 测试按 DataKey 分组聚合
   - 测试 DisplayName 优先于 DataKey 显示
   - 测试 DataKey 作为回退显示名称

3. **集成测试** (GameAutomationPlaytimeIntegrationTests):
   - 已存在的测试需要更新，确保使用 DataKey
   - 测试完整流程：匹配 -> 跟踪 -> CSV 写入 -> stats 读取
   - 测试混合场景：有些游戏有 DisplayName，有些没有

4. **回归测试**:
   - 使用历史 `playtime.csv` 验证数据仍可读取
   - 确认新记录与旧记录格式兼容

### 项目结构遵循

**来源**: [docs/architecture/4-source-tree-and-module-organization.md]

- `GameHelper.Infrastructure/Providers/CsvBackedPlayTimeService.cs` - 数据持久化实现
- `GameHelper.ConsoleHost/Commands/StatsCommand.cs` - CLI 命令实现
- `GameHelper.Tests/CsvBackedPlayTimeServiceTests.cs` - 单元测试
- `GameHelper.Tests/StatsCommandIntegrationTests.cs` - 集成测试
- `GameHelper.Tests/GameAutomationPlaytimeIntegrationTests.cs` - 端到端测试

### 编码标准

**来源**: [docs/architecture/coding-standards.md]

关键点：
- 使用 `_logger.LogInformation("Recording session for {GameDataKey}", dataKey)` 进行结构化日志
- 所有字符串比较使用 `StringComparer.OrdinalIgnoreCase`
- 异常处理：使用 `ArgumentNullException.ThrowIfNull()` 验证参数
- 文件操作：保持现有的重试逻辑和原子写入模式
- 测试命名：`MethodName_Scenario_ExpectedBehavior`

### 技术约束

**来源**: [docs/architecture/tech-stack.md]

- .NET 8.0 运行时
- CSV 解析和写入使用内建方法（无外部 CSV 库）
- 时间格式：ISO 8601 (`yyyy-MM-ddTHH:mm:ss`)
- 文件编码：UTF-8
- 线程安全：使用 `lock (_gate)` 保护并发访问

### 数据兼容性要求

**关键设计决策**：

**Story 1.4 的职责（简化版）**：
- ✅ 只需要支持**新格式**（DataKey 格式）的实现
- ✅ 测试使用**新的配置文件和 CSV 数据**
- ✅ 不需要处理旧数据兼容性或迁移逻辑
- ✅ 干净、简单的实现

**Story 1.5 的职责**：
- 📋 检测用户现有的配置和 CSV 数据
- 📋 如果发现旧格式（EXE 名称），提供迁移工具
- 📋 负责将用户数据从旧格式迁移到新格式
- 📋 这是处理**所有兼容性问题**的地方

**实现策略**：

1. **新会话写入**：
   - 使用 `GameConfig.DataKey` 写入 CSV

2. **Stats 命令读取**：
   - 按 CSV 的 `game` 列（预期是 DataKey）直接分组
   - 尝试匹配 DataKey 以获取 DisplayName
   - 如果找不到配置，显示 CSV 原始值（处理孤立记录）

3. **测试数据**：
   - ✅ 使用新格式的测试配置
   - ✅ 使用新格式的测试 CSV（game 列 = DataKey）
   - ❌ 不测试旧格式数据
   - ❌ 不测试混合格式场景

**关键约束**：
1. **专注新格式**: Story 1.4 只实现和测试 DataKey 格式 ✅
2. **清晰职责**: 旧数据迁移完全由 Story 1.5 处理 ✅
3. **简单实现**: 无需复杂的兼容性逻辑 ✅

## Tasks / Subtasks

- [ ] 验证 GameAutomationService 传递正确的 DataKey (AC: 1)
  - [ ] 检查 `GameAutomationService.cs` 中调用 `StartTracking` 的位置
  - [ ] 确认传递的参数是 `config.DataKey` 而不是 `exeName` 或其他值
  - [ ] 检查 `StopTracking` 调用同样使用 `config.DataKey`
  - [ ] 如果当前未使用 DataKey，修改为使用 DataKey

- [ ] 更新 CsvBackedPlayTimeService 确保使用 DataKey (AC: 1)
  - [ ] 审查 `AppendSessionToCsv` 方法的当前实现
  - [ ] 确认参数 `gameName` 实际接收的是 `DataKey`
  - [ ] 添加日志记录：`_logger.LogDebug("Recording session for {DataKey}", gameName)`
  - [ ] 验证 CSV 写入的 `game` 列包含正确的 DataKey
  - [ ] 确保特殊字符（逗号、引号）通过 `EscapeCsvField` 正确转义

- [ ] 更新 StatsCommand 使用 DisplayName 优先逻辑 (AC: 3)
  - [ ] 修改第 67 行：将 `gc.Alias` 改为 `gc.DisplayName`
  - [ ] 实现简化的显示逻辑：
    - [ ] 如果 CSV 的 `game` 值匹配到 DataKey，且有 DisplayName，使用 DisplayName
    - [ ] 如果匹配到 DataKey，但无 DisplayName，使用 DataKey
    - [ ] 如果无法匹配（旧数据），直接使用 CSV 原始值
  - [ ] 更新代码逻辑（见 Dev Technical Guidance 中的简化代码）
  - [ ] 测试显示名称优先级正确

- [ ] 验证 stats 命令按 DataKey 分组 (AC: 2)
  - [ ] 审查 `PlaytimeDataReader.ReadFromCsv` 实现
  - [ ] 确认从 CSV 读取时，`game` 列映射到 `GameItem.GameName`
  - [ ] 验证分组逻辑按 `GameName`（即 DataKey）分组
  - [ ] 处理孤立记录（CSV 中存在但配置中不存在的游戏）

- [ ] 添加和更新单元测试 (AC: 1, 2, 3)
  - [ ] **CsvBackedPlayTimeServiceTests.cs**:
    - [ ] 测试 `StartTracking` 和 `StopTracking` 使用 DataKey
    - [ ] 测试 CSV 写入包含特殊字符的 DataKey（逗号、引号）
    - [ ] 测试会话记录后 CSV 文件包含正确的 DataKey
  - [ ] **StatsCommandIntegrationTests.cs**:
    - [ ] 测试按 DataKey 分组聚合游戏时长
    - [ ] 测试 DisplayName 优先于 DataKey 显示
    - [ ] 测试 DataKey 作为回退显示名称
    - [ ] 测试多个游戏的混合场景（有些有 DisplayName，有些没有）
    - [ ] 测试孤立记录（CSV 中存在但配置中不存在）正常显示
  - [ ] **GameAutomationPlaytimeIntegrationTests.cs**:
    - [ ] 更新现有测试使用 DataKey
    - [ ] 添加端到端测试：匹配 -> 跟踪 -> CSV 写入 -> stats 读取

- [ ] 执行测试验证新格式功能 (AC: 1, 2, 3, 4)
  - [ ] 创建新格式的测试配置和 CSV 数据
  - [ ] 示例新格式记录：`elden_ring,2024-11-01T10:00:00,2024-11-01T12:00:00,120`
  - [ ] 配置示例：`DataKey: "elden_ring", DisplayName: "Elden Ring"`
  - [ ] 运行 stats 命令，验证：
    - [ ] 正确按 DataKey 分组
    - [ ] 显示 DisplayName 而不是 DataKey
    - [ ] 处理没有 DisplayName 的情况
    - [ ] 处理孤立记录（CSV 中有但配置中没有）
  - [ ] 测试边界情况：
    - [ ] 空 CSV 文件（只有表头）✅
    - [ ] CSV 包含特殊字符的 DataKey（逗号、引号）✅
    - [ ] 多个游戏的聚合和排序 ✅
  - [ ] **注意**: 不测试旧格式数据，旧数据迁移由 Story 1.5 处理

- [ ] 更新文档
  - [ ] 如需修改 CSV 格式或 API，更新 `docs/history/Bug_Fix_Summary_zh.md`
  - [ ] 如影响 CLI 使用，更新 `docs/history/CLI_Manual_zh.md`
  - [ ] 在 `docs/architecture/5-data-models-and-storage.md` 中确认数据关联描述正确

## Testing

### 单元测试场景

**CsvBackedPlayTimeService 测试**：
```csharp
[Fact]
public void StopTracking_ShouldWriteDataKeyToCsv()
{
    // Given: 使用 DataKey "Elden Ring" 开始跟踪
    var service = new CsvBackedPlayTimeService(testDir);
    service.StartTracking("Elden Ring");
    
    // When: 停止跟踪
    service.StopTracking("Elden Ring");
    
    // Then: CSV 文件应包含 "Elden Ring" 作为 game 列的值
    var csvContent = File.ReadAllText(csvPath);
    csvContent.Should().Contain("Elden Ring");
}

[Fact]
public void StopTracking_ShouldEscapeSpecialCharactersInDataKey()
{
    // Given: DataKey 包含逗号
    var dataKey = "Game, The: Special Edition";
    var service = new CsvBackedPlayTimeService(testDir);
    service.StartTracking(dataKey);
    
    // When: 停止跟踪
    service.StopTracking(dataKey);
    
    // Then: CSV 应正确转义逗号
    var csvContent = File.ReadAllText(csvPath);
    csvContent.Should().Contain("\"Game, The: Special Edition\"");
}
```

**StatsCommand 测试**：
```csharp
[Fact]
public void DisplayStats_ShouldUseDisplayNameWhenAvailable()
{
    // Given: 配置有 DisplayName
    var config = new GameConfig 
    { 
        DataKey = "elden_ring", 
        DisplayName = "Elden Ring" 
    };
    
    // When: CSV 包含 DataKey "elden_ring"
    // Then: 应显示 "Elden Ring" (DisplayName)
}

[Fact]
public void DisplayStats_ShouldFallbackToDataKeyWhenNoDisplayName()
{
    // Given: 配置没有 DisplayName
    var config = new GameConfig 
    { 
        DataKey = "elden_ring", 
        DisplayName = null 
    };
    
    // When: CSV 包含 DataKey "elden_ring"
    // Then: 应显示 "elden_ring" (DataKey)
}

[Fact]
public void DisplayStats_ShouldShowOriginalValueForOrphanedRecords()
{
    // Given: 
    // - CSV 包含: "unknown_game,..."
    // - 配置中不存在 DataKey="unknown_game"
    
    // When: 运行 stats 命令
    
    // Then: 
    // - 应显示 "unknown_game" (CSV 原始值)
    // - 不报错，正常显示统计数据
}

[Fact]
public void DisplayStats_ShouldGroupByDataKey()
{
    // Given: 
    // - CSV 包含多条 "elden_ring" 的记录
    // - 配置: DataKey="elden_ring", DisplayName="Elden Ring"
    
    // When: 运行 stats 命令
    
    // Then:
    // - 所有 "elden_ring" 记录应聚合为一个条目
    // - 显示总时长和会话数
    // - 显示名称为 "Elden Ring"
}
```

### 集成测试场景

**GameAutomationPlaytimeIntegrationTests**：
```csharp
[Fact]
public async Task EndToEnd_ShouldRecordDataKeyInCsvAndDisplayCorrectly()
{
    // Given: 配置使用 DataKey "elden_ring" 和 DisplayName "Elden Ring"
    var config = new GameConfig
    {
        DataKey = "elden_ring",
        ExecutablePath = @"C:\Games\EldenRing.exe",
        DisplayName = "Elden Ring",
        IsEnabled = true
    };
    
    // When: 
    // 1. 模拟进程启动并匹配
    // 2. GameAutomationService 开始跟踪
    // 3. 进程结束，停止跟踪
    // 4. 运行 stats 命令
    
    // Then:
    // 1. CSV 应包含 "elden_ring" 作为 game 列
    // 2. stats 命令应显示 "Elden Ring"（DisplayName）
    // 3. 聚合应按 "elden_ring"（DataKey）分组
}
```

### 回归测试场景

**向后兼容性测试**：
1. 创建包含旧格式记录的 `playtime.csv`（使用游戏 EXE 名称作为 game 列）
2. 添加新格式记录（使用 DataKey）
3. 运行 stats 命令，验证两种格式都能正确读取和显示

### 测试执行命令

```powershell
# 运行所有测试
dotnet test GameHelper.sln

# 仅运行相关测试
dotnet test --filter "FullyQualifiedName~CsvBackedPlayTimeService"
dotnet test --filter "FullyQualifiedName~StatsCommand"
dotnet test --filter "FullyQualifiedName~GameAutomationPlaytime"

# 运行集成测试
dotnet test --filter "Category=Integration"
```

## Definition of Done

- [ ] 所有验收标准已满足
- [ ] `CsvBackedPlayTimeService` 使用 `DataKey` 记录会话
- [ ] `StatsCommand` 正确显示 `DisplayName` 或 `DataKey`
- [ ] `StatsCommand` 按 `DataKey` 正确分组
- [ ] 所有单元测试通过
- [ ] 所有集成测试通过
- [ ] 回归测试通过（历史数据兼容）
- [ ] 代码通过 Code Review
- [ ] 文档已更新（如需要）
- [ ] 无引入新的技术债务

## Notes

### 重要提醒
- **简化实现**: Story 1.4 只负责正确使用 DataKey，不处理复杂的跨格式匹配
- **数据兼容性**: 旧数据可以读取和显示，但显示为原始 EXE 名称
- **清晰职责分离**: 历史数据的迁移和合并由 **Story 1.5 的数据修复工具**专门处理
- **显示名称回退**: DisplayName > DataKey > CSV 原始值
- **GameConfig.Alias 问题**: 当前代码引用 `Alias` 属性，但模型中不存在此字段，需改为 `DisplayName`

### 潜在风险
- **旧新数据分离**: 用户会看到同一游戏的两个条目（旧 EXE 名称 + 新 DataKey），需要通过 Story 1.5 的工具迁移
- **用户认知**: 需要向用户说明旧数据迁移的方式（通过 Story 1.5 的命令）

### 技术债务
- 无新增技术债务

## Change Log

| Date       | Version | Description | Author |
| ---------- | ------- | ----------- | ------ |
| 2025-11-10 | 0.1     | 初始草稿   | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

_待开发代理填写_

### Debug Log References

_待开发代理填写_

### Completion Notes

_待开发代理填写_

### File List

_待开发代理填写_
